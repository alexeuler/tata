use crate::ffi::ByteArray;

use serde::{Deserialize, Serialize};
use std::convert::{TryFrom, TryInto};

/// Plain text message sent by peer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlainTextMessage {
    pub to: String,
    pub timestamp: u64,
    pub text: String,
}

/// Error at the network level
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ErrorMessage {
    /// Dial failed for some reason
    FailedToDial { cause: String },
    /// Network error
    Network { cause: String },
    /// Invalid message was passed
    MessageValidation { timestamp: u64, cause: String },
    /// Other
    Other { cause: String },
}

/// Event generated in a process of communication with a certain peer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerEvent {
    pub peer_id: String,
    pub event: Event,
}

/// Event generated by network layer
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Event {
    /// Received plain text message sent by peer
    ReceivedPlainTextMessage { message: PlainTextMessage },
    /// Received metadata from peer
    ReceivedMetadata { name: String },
    /// Sent plain text message with timestamp
    SentPlainTextMessage { timestamp: u64 },
    /// A new peer discovered
    PeerDiscovered,
    /// A peer is gone
    PeerGone,
    /// Error
    Error { error: ErrorMessage },
}

impl TryInto<ByteArray> for PeerEvent {
    type Error = serde_json::error::Error;
    fn try_into(self) -> Result<ByteArray, serde_json::error::Error> {
        let bytes = serde_json::to_vec(&self)?;
        Ok(bytes.into())
    }
}

impl TryFrom<ByteArray> for PeerEvent {
    type Error = serde_json::error::Error;
    fn try_from(array: ByteArray) -> Result<PeerEvent, serde_json::error::Error> {
        let bytes: Vec<u8> = array.into();
        let event = serde_json::from_slice(&bytes)?;
        Ok(event)
    }
}
