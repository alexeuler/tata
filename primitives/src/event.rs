use crate::ffi::ByteArray;

use serde::{Deserialize, Serialize};
use std::convert::{TryFrom, TryInto};

/// Plain text message sent by peer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlainTextMessage {
    pub from: String,
    pub timestamp: u64,
    pub text: String,
}

/// Error at the network level
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ErrorMessage {
    /// Dial failed for some reason
    FailedToDial { peer_id: String, reason: String },
    /// Network error
    Network { peer_id: String, reason: String },
    /// Invalid message was passed
    MessageValidation { timestamp: u64, reason: String },
    /// Other
    Other { reason: String },
}

/// Event generated by network layer
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", content = "payload")]
pub enum Event {
    /// Received plain text message sent by peer
    ReceivedPlainTextMessage(PlainTextMessage),
    /// Received metadata from peer
    ReceivedMetadata { peer_id: String, name: String },
    /// Sent plain text message with timestamp
    SentPlainTextMessage { timestamp: u64 },
    /// A new peer discovered
    PeerDiscovered { peer_id: String },
    /// A peer is gone
    PeerGone { peer_id: String },
    /// Error
    Error(ErrorMessage),
}

impl TryInto<ByteArray> for Event {
    type Error = serde_json::error::Error;
    fn try_into(self) -> Result<ByteArray, serde_json::error::Error> {
        let bytes = serde_json::to_vec(&self)?;
        Ok(bytes.into())
    }
}

impl TryFrom<ByteArray> for Event {
    type Error = serde_json::error::Error;
    fn try_from(array: ByteArray) -> Result<Event, serde_json::error::Error> {
        let bytes: Vec<u8> = array.into();
        let event = serde_json::from_slice(&bytes)?;
        Ok(event)
    }
}
